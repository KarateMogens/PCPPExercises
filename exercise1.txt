Exercise 1.1 - PCPP - Deadlock

1. ThemainmethodcreatesaLongCounterobject.Thenitcreatesandstartstwothreadsthatrunconcurrently, and each increments the count field 10 million times by calling method increment.
What output values do you get? Do you get the expected output, i.e., 20 million?

-- When running the programme, we get different outputs each time the programme is run, all being under 20 million. 

2. Reduce the counts value from 10 million to 100, recompile, and rerun the code. It is now likely that you get the expected result (200) in every run.
Explain how this could be. Is it guaranteed that the output is always 200?

-- Since the runtime of each thread is so short, in most cases t1 will finish the complete execution of the for-loop, before t2 is even started. Therefore you don't have any data being overwritten. This is because the process of starting a new thread is a quite heavy operation in itself.

- It is not guaranteed, that we will get an output of 200 each time. The first rerun executed with the output 188. 

3. Do you think it would make any difference to use one of these forms instead? Why? Change the code and run it. Do you see any difference in the results for any of these alternatives?

-- No, it does not make a difference to use any of the other forms. This is because updating a variable cannot be a fully atomic operation.

4. Set the value of counts back to 10 million. Use Java ReentrantLock to ensure that the output of the program equals 20 million. Explain why your solution is correct, and why no other output is possible.
Note: In your explanation, please use the concepts and vocabulary introduced during the lecture, e.g., critical sections, interleavings, race conditions, mutual exclusion, etc.
Note II: The notes above applies to all exercises asking you to explain the correctness of your solution.

-- Introducing the lock around the critical section of the increment method, ensures that each thread does not overwrite data in the shared memory, that the other thread is accessing. Thereby we ensure mutual exclusion of the two threads and therefore elimination of the race condition.

5. By using the ReetrantLock in the exercise above, you have defined a critical section. Does your critical section contain the least number of lines of code? If so, explain why. If not, fix it and explain why your new critical section contains the least number of lines of code.

-- It does, because the critical section in the code consists of the statement count = count +1, which accesses shared memory, and which cannot be divided into more atomic statements which aren't critical. 


Exercise 1.2 Consider this class, whose print method prints a dash “-”, waits for 50 milliseconds, and then prints a vertical bar “|”:
  class Printer {
    public void print() {
      System.out.print("-"); //(1)
      try { Thread.sleep(50); } catch (InterruptedException exn) { } //(2)
      System.out.print("|"); //(3)
  }
}

2. Describe and provide an interleaving where this happens.

- With the numbering in the print method above and the two threads t1 and t2, such a possible interleaving could be:
t1(1) t1(2) t2(1) t2(2) t1(3) t2(3)

3. Use Java ReentrantLock to ensure that the program outputs the expected sequence -|-|-|-|....
Compile and run the improved program to see whether it works. Explain why your solution is correct, and why it is not possible for incorrect patterns, such as in the output above, to appear.
